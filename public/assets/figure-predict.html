<style>
  figure-predict {
    display: block;
    position: relative;
    height: 600px;
  }
  figure-predict svg {
    pointer-events: none;
    position: absolute;
    display: block;
    width: 100%;
    height: 150px;
    border: 1px solid black
  }
  figure-predict #user-input {
    position: absolute;
    display: block;
    width: 100%;
    height: 150px;

  }

  figure-predict #prediction-output {
    position: absolute;
    top: 200px;
    left: 0px;
    display: block;
    width: 100%;
    height: 150px;

  }

  figure-predict .user path {
    fill: none;
    stroke: rgb(49, 145, 137);
    stroke-width: 1.5px;
  }
  figure-predict .user circle {
    fill: rgb(49, 145, 137);
  }
  figure-predict .user line {
    stroke: #ddd;
    stroke-dasharray: 3,3;
  }
  figure-predict .user .prompt circle {
    fill: none;
    stroke: #ddd;
  }
  figure-predict .user .prompt text {
    font-size: 13px;
    fill: #aaa;
  }
</style>

<dom-module id="figure-predict">
  <template>
    <svg>
      <g class="user">
        <g class="prompt">
        </g>
        <path></path>
      </g>
      <g class="predictions">

      </g>
    </svg>
      <canvas id = "user-input"></canvas>
    <canvas id = "prediction-output"></canvas>
  </template>

</dom-module>

<script>
Polymer({
  is: "figure-predict",
  initialize: function() {
    console.log("init");
    this.color = d3.scaleSequential(d3.interpolateBrBG).domain([-3, 3]);
    var that = this;
    this.root = d3.select(this);

    this.canvas = this.root.select("canvas");
    this.userCanvas = this.root.select("#user-input");
    this.predictionCanvas = this.root.selectAll( "#prediction-output");

    this.svg = this.root.select("svg");

    this.xScale = d3.scaleLinear();
    this.yScale = d3.scaleLinear();

    this.predictionLength = +this.getAttribute("predictionlength");
    this.temperature = +this.getAttribute("temperature");
    this.userCoordinates = [];

    this.predictionStack = [];

    this.pending = false;
    this.count = 0;

    this.worker = new Worker("assets/worker-predict.js");
    this.worker.onmessage = function(event) {
    that.renderCoordinates.call(that, that.userCoordinates, that.userContext);

    if( that.predictionStack.length  > 3) { that.predictionStack = []}
    that.predictionStack.push(event.data[2]);
    //that.renderPrediction.call(that, (Math.random() * 40) ,  (Math.random() * 40) , event.data[2]);
    that.pending = false;
      if (that.playing) that.play();
    }

    setInterval(this.renderPrediction, 2000, that);

    window.addEventListener("resize", this.resize.bind(this));
    this.reset();
    setTimeout(this.reset.bind(this), 500);
  },
  play: function() {
    this.playing = true;
    if (!this.pending) {
      this.pending = true;
      this.worker.postMessage({
        predict: this.predictionLength,
        temperature: this.temperature
      });
    }
  },

  togglePending : function(that)
  {
    that.pending = !that.pending;
  },


  pause: function() {
    this.playing = false;
  },
  resize: function() {

    var bbox = this.getBoundingClientRect();

    this.width = bbox.width;
    this.height = bbox.height;
    this.width  = this.root.select("svg").attr("width");
    this.height = this.root.select("svg").attr("height");
    this.temperature = +this.getAttribute("temperature");

    this.userCanvas.property("width", this.width);
    this.userCanvas.property("height", this.height);

    this.context = this.canvas.node().getContext("2d");
    this.userContext = this.userCanvas.node().getContext("2d");
    this.predictionContext = this.predictionCanvas.node().getContext("2d");

    var zoom = 18;
    this.origin = [150, this.height / 3];

    this.xScale.domain([0, 100]).range([this.origin[0], this.origin[0] + zoom * 100]);
    this.yScale = d3.scaleLinear().domain([0, 100]).range([this.origin[1], this.origin[1] + zoom * 100]);
    console.log(this.xScale + " " + this.yScale);

  },
  reset: function() {
    this.resize();
    this.x = this.xScale(0);
    this.y = this.yScale(0);
    this.dx = 0;
    this.dy = 0;
    this.userCoordinates = [];
    this.clearCanvas();
    this.renderCoordinates(this.userCoordinates, this.userContext);
    this.worker.postMessage({
      reset: true,
    });
    // this.play();
  },
  ready: function() {
    var that = this;
    console.log("ready");
    this.initialize();

    var drag = d3.drag()
        .container(this) //do I need to change this?
        .on("start", drawStart) // after a new pointer becomes active (on mousedown or touchstart)
        .on("drag", draw) // after an active pointer moves (on mousemove or touchmove)
        .on("end", drawEnd);

    //this.userCanvas.call(drag);
    this.userCanvas.call(drag);

    distill.stageManager.add(this, {
      enterStage: this.play,
      exitStage: this.pause
    });

    this.play();

    //var context = this.context;
    this.tempdx = 0;
    this.tempdy = 0;
    this.tempx = 0;
    this.tempy = 0;

    function drawStart() {
      // if (that.userCoordinates.length) {
      //   that.userCoordinates[that.userCoordinates.length - 1][2] = 1;
      // }
      console.log("drawStart");
      that.resetPrediction();
      that.dx = that.xScale.invert(d3.event.x) - that.xScale.invert(that.x);
      that.dy = that.yScale.invert(d3.event.y) - that.yScale.invert(that.y);
      that.userCoordinates.push([that.dx, that.dy, 0]);
      that.worker.postMessage({update: [that.dx, that.dy, 0]});
      that.clearCanvas();
      that.renderCoordinates.call(that, that.userCoordinates, that.userContext);
      that.tempdx = 0;
      that.tempdy = 0;
      that.tempx = d3.event.x;
      that.tempy = d3.event.y;
    }

    function draw() {
      that.resetPrediction();
      that.tempdx = d3.event.dx + that.tempdx;
      that.tempdy = d3.event.dy + that.tempdy;
      if ((that.tempdx * that.tempdx + that.tempdy * that.tempdy) > 30) {
        that.dx = that.xScale.invert(that.tempx) - that.xScale.invert(that.tempx - that.tempdx);
        that.dy = that.yScale.invert(that.tempy) - that.yScale.invert(that.tempy - that.tempdy);
        that.userCoordinates.push([that.dx, that.dy, 0]);
        that.worker.postMessage({update: [that.dx, that.dy, 0]});
        that.clearCanvas();
        that.renderCoordinates.call(that, that.userCoordinates, that.userContext);
        that.tempx = d3.event.x;
        that.tempy = d3.event.y;
        that.tempdx = 0;
        that.tempdy = 0;
        //console.log("coords", that.userCoordinates)
      }
    }

    function drawEnd() {
      that.resetPrediction();
      if ((that.tempdx * that.tempdx + that.tempdy * that.tempdy) <= 30) {
        that.dx = that.xScale.invert(that.tempx) - that.xScale.invert(that.tempx - that.tempdx);
        that.dy = that.yScale.invert(that.tempy) - that.yScale.invert(that.tempy - that.tempdy);
        that.userCoordinates.push([that.dx, that.dy, 1]);
        that.worker.postMessage({update: [that.dx, that.dy, 1]});
        that.clearCanvas();
        that.renderCoordinates.call(that, that.userCoordinates, that.userContext);
        that.tempx = d3.event.x;
        that.tempy = d3.event.y;
        that.tempdx = 0;
        that.tempdy = 0;
      }
      that.x = d3.event.x;
      that.y = d3.event.y;
    }
  },
  clearCanvas: function() {
    this.userContext.clearRect(0, 0, this.width, this.height);
  },
  renderCoordinates: function(coordinates, context) {
    var that = this;

    var prompt = this.svg.selectAll(".prompt").data([0]);

    var promptEnter = prompt.enter().append("g").attr("class", "prompt");

    var padding = this.width > 800 ? 100 : 75;

    this.svg.select(".user line")
        .attr("x1", padding)
        .attr("x2", this.width - padding)
        .attr("y1", this.origin[1] + padding)
        .attr("y2", this.origin[1] + padding);

    this.svg.select(".prompt")
        .attr("transform", "translate(" + this.origin[0] + "," + this.origin[1] + ")");

    this.svg.select(".user path")
        .attr("d", path(coordinates));

    function path(coordinates) {
      var d = "M" + that.origin[0] + "," + that.origin[1];

      var x = 0, y = 0, p = 1;
      coordinates.forEach(function(c) {
        var dx = c[0], dy = c[1];
        //   context.moveTo(that.xScale(x), that.yScale(y));
        d += p ? "M" : "L";
        d += that.xScale(x + dx) + "," + that.yScale(y + dy);
        c.x = x;
        c.y = y;
        p = c[2];
        x += dx;
        y += dy;
      });
      return d;
    }

    var user = this.svg.select(".user")
    var userPoint = user.selectAll(".point")
        .data(coordinates);

    var userPointEnter = userPoint.enter().append("circle")
        .attr("class", "point")
        .attr("r", 1.5);

    userPoint.merge(userPointEnter)
        .attr("cx", function(d) { return that.xScale(d.x + d[0]); })
        .attr("cy", function(d) { return that.yScale(d.y + d[1]); });

    userPoint.exit().remove();
  },

  //renderPrediction: function(x1, y1, coordinates)
  renderPrediction: function(that) {
    //var that = this;
    console.log(that.predictionStack.length + " " + that.count);

    if(that.predictionStack.length > 0 && that.playing && that.count < 20)
    {
      coordinates = that.predictionStack.pop();
      x1 = Math.random() * 40;
      y1 = Math.random() * 40;

      that.predictionContext.lineWidth = 1;
      var red = Math.floor( Math.random() * 255);
      var blue = Math.floor(Math.random() * 255);
      var green = Math.floor(Math.random() * 255);
      //var magnifaction = Math.random() * 20;
      var magnifaction = 5;

      that.context.fillRect(0, 0, that.width, that.height);
      //sthat.predictionContext.strokeStyle = "rgb(" + red + ", "+ blue + ", " + green + ")"
      that.predictionContext.fillStyle = "rgba(" + red + ", " + blue + ", " + green + ", 0.2)"
      var penState = that.userCoordinates.length ? that.userCoordinates[that.userCoordinates.length - 1][2] : 1;

      that.predictionContext.beginPath();
      x2 = x1;
      y2 = y1;
      var v;
      coordinates.forEach(function(coords) {
        var dx = coords[0]  * magnifaction,
            dy = coords[1] * magnifaction;
        that.predictionContext.moveTo(x1, y1);
        if (!penState){
          that.predictionContext.lineTo(x1 + dx, y1 + dy);
        }
        else {
          that.predictionContext.beginPath()
        }

        that.predictionContext.stroke();
        that.predictionContext.fill();
        penState = coords[2];
        x1 = x1 + dx;
        y1 = y1 + dy;

      });
      that.count = that.count + 1;
    }
  },

  //
  // Events
  //

  playToggle: function() {
    this.playing = !this.playing;
    if(this.playing) this.play();
  },

  setTest: function() {
    //alert(this.svg.select(".user path").attr("d"))
    //alert(this.svg.select(".prompt").text())
    this.svg.select(".prompt text").text( this.svg.select(".user path")
        .attr("d"));

  },


  setTemperature: function(val) {
    this.temperature = +val;
    this.resetPrediction();
  },
  setPredictionLength: function(val) {
    this.predictionLength = +val;
    this.resetPrediction();
  },
  clear: function() {
    this.reset();
  },

  resetPrediction: function() {
    this.predictionStack = [];
    this.count = 0;
  },

  Grab: function(evt) {
    console.log("svgGrab");
  },

   Drag: function(evt) {
     console.log("svgDrag");
   },

   Drop: function(evt) {
     console.log("svgDrop");
   }


});
</script>
